

1.扎实的Java基础，对集合框架，多线程并发等有着深入的理解 
2.精通spring，mybatis等开源框架，对源码有一定的理解
3.熟悉jvm底层，熟悉jvm内存结构、gc回收算法
4.熟练掌握常用的设计模式，并且运用到实际的开发中 
5.熟练掌握并发编程，对AQS和CAS锁竞争有实际应用经验
6.熟练掌握mysql，了解mysql数据库存储结构和索引机制 
7.熟练掌握zookeeper服务治理以及nginx集群配置
8.熟练掌握redis开发和设计，了解各类缓存的底层机制
9.熟练掌握activemq,kafka消息中间件，能根据实际项目场景给出方案



基本特征
?	每行数据都存在一个版本，每次数据更新时都更新该版本。
?	修改时Copy出当前版本随意修改，各个事务之间无干扰。
?	保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）


InnoDB存储引擎MVCC的实现策略
在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）。这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。

每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。

1.插入数据（insert）:记录的版本号即当前事务的版本号
2、在更新操作的时候，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式。

3、删除操作的时候，就把事务版本号作为删除版本号。

4、查询操作：

从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来：

1) 删除版本号未指定或者大于当前事务版本号，即查询事务开启后确保读取的行未被删除。(即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)

2) 创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事物进行的insert。

（即事务id为2的事务只能读取到create version<=2的已提交的事务的数据集）

补充：

1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.

2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.

原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。

3.串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。

4.通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。

sql优化
1.查询语句中尽量不适用 *
2.尽量减少子查询，使用关联查询（left join，right join，inner join）替代
3.减少使用IN或者NOT IN，使用exists，not exists或者关联查询语句替代
4.使用union或者union all代替or查询（确认没有重复数据或者不用剔除重复数据时，union all性能更好，解释器不用再扫描一遍表挑选重复）
5.建表的时候能使用数字类型字段就不要使用字符串，数字类型的字段作为查询条件比字符串快。
6.那些能过滤掉最大数量记录的条件必须写在where子句的最末尾。
7.查询字段很多的情况下，慎用distinct关键字，会大大降低查询效率。
8.定义字段时，尽量使用varchar而不是char。定义一个char[10]和varchar[10],如果存进去的是‘abcd’,
那么char所占的长度依然为10，除了字符‘abcd’外，

建立合适索引
索引失效的查询
getJrafSession

数据库分库分表


业务上的优化









