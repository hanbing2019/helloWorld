阻塞io模式
最传统的io模型，在读写数据过程中会发生阻塞现象	；用户线程发生io请求时，检查数据时候就绪，如果数据没有就绪
就会等待数据准备就绪，线程处于阻塞状态，用户交出cpu;当数据就绪后，用户线程才解除阻塞状态
非阻塞io模式
当用户线程发起一个read操作后，不需要等待，而是马上就得到一个结果，如果是一个Error，那么就是数据还没有准备好，那么就
再次发送read操作，一旦数据准备好之后，并且又收到用户请求，那么当前用户线程就能马上执行；在非io阻塞模型中，用户线程不断的
询问数据是否就绪，也就是说非io不用交出cpu
非阻塞模式是在代码中使用while循环来实现的


多路复用io
java nio就是使用的是	多路复用io
会有一个线程不断的轮询多个socket状态，只有当socket真正读取到数据时，才真正调用实际的io读写操作
多路复用io轮询socket状态是在内核中进行的（在操作系统层），所以效率比非阻塞io高，