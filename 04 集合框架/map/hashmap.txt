hashmap是不是有序的
不是
有没有顺序的map实现类
treemap
linkedhashMap
TreeMap和LinkedHashMap是如何保证它的顺序的？
treemap保证的是添加的值的顺序性
linkedhashmap保证的是添加的顺序性

ArrayList和LinkedList底层是用什么数据结构实现的。
答：ArrayList是使用数组实现的，LinkedList是使用链表实现的。

链表和数组有啥特点或者区别；
答：
a)数组是内存中的一块连续区域。链表是用节点对象实现，节点对象包含了前驱节点和后继节点以及节点包含的数据对 象。
（ E item; Node next;Node prev;）。链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。
b) 链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难；
数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要再编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便。

链表都有几种结构；
答：单向，双向和循环。回答这些问题的时候可以适当的在纸上画一下，这样效果更好。

HashMap主要有哪些方法？
答：常用的有put,get等等的，

描述一下put的过程。
答：
1.对Key求Hash值，然后再计算下标
2.如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）
3.如果碰撞了，以链表的方式链接到后面
4.如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于 6，就把红黑树转回链表
5.如果节点已经存在就替换旧值
6.如果桶满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排）

为什么超过8才转换为红黑树呢，有没有考虑过。
这个问题比较偏有的面试官压根问不到，即使问到了你答不上其实也还好，这时候你可以反问他一下。
当然你真的好奇然后研究过原因能答出来，是一个加分点，会让面试官眼前一亮。
答：我思考过，当数字是8的时候，红黑树的平均查找长度小于链表，（长度为8时，红黑树的平均查找长度为3，链表为4.），
但是我也有点疑问，因为链表转换为红黑树本身也会影响性能。后来我看到了HashMap源码上方有一段注释。翻译过来大概的意思是：
理想情况下使用Key的哈希码，容器中节点分布在hash桶中的频率遵循泊松分布，按照泊松分布的计算公式计算出的结果，
链表中元素个数为8时的概率已经非常小大概是千万分之6，再多的就更少了，所以原作者在选择链表元素个数时选择了8，
是根据概率统计而选择的。

让hashmap满足线程安全
使用collections的synchronizedMap方法使hashmap具有线程安全的能力，或者使用Concurrenthashmap

什么是hash冲突，怎么解决
哈希冲突是指哈希函数算出来的地址被别的元素占用了，也就是，这个位置有人了
使用拉链法，将所有关键字为同义词的结点链接在同一个单链表中


A：您应聘的是Java岗位是吧，使用过Java的集合框架吗？
B：使用过，比如ArrayList、HashMap、HashSet……巴拉巴拉……

A：说说您对HashMap的理解？
B：HashMap是常用的Java集合之一，是基于哈希表的Map接口的实现。设计目标是尽量实现哈希表O(1)级别的增删改查效果，默认容量是16，
扩容因子……底层结构是……巴拉巴拉……

A：说到HashMap的底层结构，您知道Java7与Java8中的HashMap有何区别吗？
B：知道，Java7的HashMap底层数据结构是数组+链表实现，而Java8是数组+链表+红黑树实现……巴拉巴拉……

A：为什么要加入红黑树呢？
B：因为在某些极端情况下，会导致大量元素都存放在同一个桶(数组索引是链表的表头)的链表中，
此时的HashMap 就相当于一个单链表，假设链表中的元素个数为n个，则其操作时间复杂度就变成了O(n)，此时就完全失去了哈希表的优势。
A：HashMap与HashTable的有何区别知道吗？
B：知道，HashMap与HashTable主要区别为不支持同步和允许null作为key和value……
A：说说HashMap线程不安全的场景？
B：1、多线程同时put时可能会丢失值。2、多线程扩容时会出现环状结构，造成死循环……巴拉巴拉……
A：如何解决HashMap的线程不安全？
B：使用 Collections 的 synchronizedMap() 对其进行包装，或是直接使用线程安全的ConcurrentHashMap……巴拉巴拉……
A：说说这两种方式的区别？
B：使用synchronizedMap包装在同步时会锁住整张表，而ConcurrentHashMap会使用自身的同步机制，比如分段锁或是CAS……
A：说说您对ConcurrentHashMap的理解？
Concurrenthashmap是一个segment数组，segment通过继承ReentrantLock来进行加锁，所以每次需要加锁的操作锁住的是一个segment，这样只要保证
每个segment线程安全，也就是实现了全局的线程安全，Concurrenthashmap默认16个segment，理论上最多支持16个并发线程写，只要他们操作分别
在不同的segment上，可以在初始化时设置其他的大小，但是一旦初始化后就不能扩容，在segment内部就是类似hashmap的实现
先根据key找到对应的segment，在segment中定义put方法完成添加


B：ConcurrentHashMap 在 JDK1.7 时被加入，是 HashMap 线程安全的版本，其使用方式与 HashMap 一样，
底层数据结构在Java7和Java8时都与HashMap相同，只是加入了线程安全的保障……巴拉巴拉……
A：说说Java7和Java8中的ConcurrentHashMap是如何保证线程安全的？
B：Java7的ConcurrentHashMap使用的是分段锁机制，
Java8抛弃了分段锁，改成使用CAS算法+synchronized关键字来保证线程安全，
加入多个分段锁浪费内存空间。
生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。
为了提高 GC 的效率
A：嗯，说说您对CAS算法的理解。
B：所谓CAS算法即Compare And Swap；比较替换，首先在内存中获取当前值，然后在和内存中的值进行比较
如果相等那么就用期望值替换内存中的值，如果不相等，那么就循环以上操作


说说你对红黑树的见解？

每个节点非红即黑
根节点总是黑色的
如果节点是红色的，则它的子节点必须是黑色的（反之不一定）
每个叶子节点都是黑色的空节点（NIL节点）
从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）


TreeMap使用红黑树来作为存储结构，保存的数据具有顺序性，
排序是更加实现Comparable接口的key或者自定义实现Comparetor接口的比较器来进行排序的，
使用哪种排序方式是初始化TreeMap对象时是否传入自定义的比较器；如果没有传入比较器就使用key的compareTo方法来进行排序，
如果key没有实现Comparable接口，并且没有传入比较器，那么添加过程就会抛出异常；如果key实现了Comparable接口并且也传入了比较器，
默认使用比较器；TreeMap类比HashMap性能要差一些，TreeMap实现的Map集合中的映射关系是根据键值对象按一定顺序排列的，
因此key不能为null；value可以为null

Hashtable实现了Map接口，用来映射key-value；key和value都不可以为null；
为了从散列表成功存储和检索对象，用作键的对象必须实现hashCode方法和equals方法；
Hashtable有2个影响性能的因数：初始容量和加载因子；通常默认的加载因子是0.75，这个值是在时间和空间上的一个折中，
加载因子更高会节省空间，但是会增加访问和操作的时间成本；

继承HashMap,实现Map接口；是由哈希表和链表组合而成的；具有hashMap的所有操作，和hashMap不同的是，
它也是可以维护节点顺序的双向链表，节点顺序默认是插入的顺序；如果再次插入相同key的节点，此时顺序是不变的；
LinkedHashMap操作的效率略低于HashMap，因为有维护链表的额外操作；
LinkedhashMap允许key和value都为null；

HashMap：基于哈希表的Map接口实现的，允许key和value为null,不能保证映射的顺序，而且不能保证在哈希表中的顺序是一直不变的
HashMap不是同步的，如果多线程同时访问了HashMap,而且其中一个线程修改了映射，则他必须保持外部同步


Treset:内部使用TreeMap来存放数据，不过数据是存放在key中的，value是自定义的一个Object对象

HashSet是通过hashMap来保存数据的，内存定义hashMap,将存储的值作为hashMap的key,保证了数据不会有重复的
LinkedHashSet
内部存储数据的是LinkedHashMap，数据存放在key中，保证数据不会有重复的


HashMap的底层数据结构？
HashMap的存取原理？
Java7和Java8的区别？
底层数据结构不一样，1.7是数组+链表，1.8则是数组+链表+红黑树结构
1.7中新增节点采用头插法，1.8中新增节点采用尾插法，针对多线程下容易造成闭环
1.7在插入数据之前扩容，而1.8插入数据成功之后扩容

为啥会线程不安全？
HashMap在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就是rehash，
这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，
如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。

在扩容的时候将原数组的内容放到新的数组中，同时有其他线程在执行put操作，如果hash值相同，可能在同一链表中造成闭环，导致get会出现
死循环




有什么线程安全的类代替么?
默认初始化大小是多少？为啥是这么多？为啥大小都是2的幂？
HashMap的扩容方式？负载因子是多少？为什是这么多？
HashMap的主要参数都有哪些？
HashMap是怎么处理hash碰撞的？
hash的计算规则？



hashmap使用红黑树结构会带来什么问题
1.红黑树结构相对链表来说较复杂，操作判断也比较复制
2.红黑树节点对象包含更多的实例，消耗过多的内存



锁粗化就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，
以降低短时间内大量锁请求、同步、释放带来的性能损耗。


首先
1.当数组长度大于0 时，
1.1如果容量超过了最大值时，扩容阈值设置为Integer.MAX_VALUE,然后返回
1.2将原长度扩大2倍（newCap = oldCap << 1），
如果扩大后的小于最大容量，并且原长度不小于默认的数组长度，
那么扩容阈值也就是原来的2倍，算出扩容后的数组长度，扩容阈值
否则当new长度大于最大容量是，新扩容阈值就是Integer的最大值，
不超过最大容量，新扩容阈值就是新长度*加载因子的结果

1.3当数组为null或者长度为0时，
那么就使用默认的数组长度和加载因子，创建数组（也就是说最开始没有创建数组）


创建新数组
扩容
如果没有初始化，那么就直接返回
如果之前已经初始化了，那么进行扩容操作（就是将原数组上的数据转移到新数组上）

遍历原数组的上的节点，如果为null不处理，如果不为null，就要整理这个节点

节点为链表时
根据节点的hash值和新数组的长度计算出新的位置将这个节点放在对应位置即可
节点是树节点


resize方法

put方法中会调用
1.在数组没有初始化时，调用这个方法来初始化数组
2.在put之后，判断当前put key的数量是否超过了扩容的阈值，如果超过了就调用来扩容


根据数组是否初始化计算出新数组的初始长度，创建数组，如果是初始化，那么就直接放回
如果是扩容那么就执行后续的扩容操作（扩容长度为原来的2倍）
扩容
就是将原数组上的数据转移到新数组上；
遍历原数组，取出root节点，判断节点
如果只有一个节点，那么获取这个节点value的hash值和（数组长度-1）进行或运算，结果就是
新数组上的下标位置
如果节点类型是TreeNode，那么调用TreeNode的split方法
如果节点是链表
遍历链表，将原数组位置上的链表转移到新的链表对象上，然后在新的位置上赋值

计算新下标：将hash值和原数组长度进行&或运算时如果结果为0，
那么就是在新数组上的位置下标就是原来的位置下标；不为0，
那么信息新下标就是原来位置下标加上原数组长度之和（结果满足hash&(newCap-1)，不用逐个计算位置下标）
遍历链表，将原链表从头开始依次转移指向新的引用对象，最终链表loHead或者hiHead指向链表的头，loTail或者hiTail指向链表的尾

Node<K,V> loHead = null, loTail = null;指向下标不变的链表
Node<K,V> hiHead = null, hiTail = null;指向下标要改变的链表（原位置下标加上原数组长度）
















